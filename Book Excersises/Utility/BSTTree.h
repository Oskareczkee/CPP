/*
BSTTree
Written by Oskar Niedüwiedzki

This binary tree can store any data type provided:
   Data type has overloaded < and > operators
   Data type has default constructor (If it has no constructors, then default one is automatically generated by compiler)

Comparator functions must return int type, must take 2 Data type arguments and make comparsion
IT MUST return:
1 if a is greater than b
-1 if a is lowet than b
0 if a is equal to b

Example:
int Comparator(hehe a, hehe b)
{
	if (a.heh > b.heh)return 1;
	if (a.heh < b.heh)return -1;
	return 0;
}

Report any bugs :)
*/
#pragma once
#include <iostream>
#include <vector>
using namespace std;
#ifndef _BSTTREE_H
#define _BSTTREE_H


/// <summary>
/// Binary Search Tree class providing Binary Tree with helper functions to manage it
/// </summary>
/// <typeparam name="DataVar">Data Variable type, to store data in node</typeparam>
template<class DataVar>
class BSTTree
{
public:
	BSTTree()
	{
		Root = NULL;
		ComparatorFunction = NULL;
		Size = 0;
	}
	~BSTTree() { Root = Erase(Root); delete Root; }

	/// <summary>
	/// Basic Node structure
	/// </summary>
	struct Node
	{
		Node* Left;
		Node* Right;
		DataVar Data;
		Node(DataVar Data) : Data(Data), Left(NULL), Right(NULL) {};
		Node() : Data(NULL), Left(NULL), Right(NULL) {};

		//TODO: check if data stays in the memory after deleting node
		//~Node() { delete Left; delete Right; /*Data = NULL;*/ }
	};

public:

	/// <summary>
	/// Creates new node with data and puts it in the tree
	/// </summary>
	/// <param name="Data">Data to put in</param>
	/// <param name="Comparator">Comparator if data has to be compared different than standard object comparator does</param>
	void Insert(DataVar Data, int(*Comparator)(DataVar a, DataVar b) = NULL) { Root = Insert(Data, Root, Comparator); };
	/// <summary>
	/// Gets a pointer to an array of content object
	/// </summary>
	/// <returns>Pointer to array of objects</returns>
	DataVar* GetContent() { return GetContent(Root); };
	/// <summary>
	/// Finds Node with speciffic data, use with ->Data on the end
	/// </summary>
	/// <param name="Data">Data to look for</param>
	/// <param name="Comparator">Comparator if data has to be compared different than standard object comparator does</param>
	/// <returns>Pointer to Node Containing Data</returns>
	Node* Find(DataVar Data, int(*Comparator)(DataVar a, DataVar b) = NULL) { return Find(Root, Data, Comparator); };
	/// <summary>
	/// Removes node with specific data
	/// </summary>
	/// <param name="Data">Data to remove</param>
	/// <param name="Comparator">Comparator if data has to be compared different than standard object comparator does</param>
	void Remove(DataVar Data, int(*Comparator)(DataVar a, DataVar b) = NULL) { Root=Remove(Data, Root, Comparator); };

	/// <summary>
	/// Returns size of BST Tree
	/// </summary>
	/// <returns>Size of tree</returns>
	int GetSize() { return Size; };

	/// <summary>
	/// Returns Comparator saved in tree
	/// </summary>
	/// <returns>Comparator function pointer</returns>
	auto ReturnComparator() ->int(*)(DataVar a, DataVar b) { return ComparatorFunction; };
	/// <summary>
	/// Sets tree comparator stored in tree
	/// </summary>
	/// <param name="comp">Pointer to comparator function</param>
	void SetComparator(int(*comp)(DataVar a, DataVar b)) { ComparatorFunction = comp; }

private:
	//Tree variables, remember to set them to null or 0 in constructors
	int Size;
	Node* Root;
	int(*ComparatorFunction)(DataVar a, DataVar b);

private:
	//Helper functions
	//In Contrast to public functions, they take RootN argument to root, so public functions can call them with original tree root
	//public functions take all arguments present in these functions except root pointer, so user don't have to care about it

	//functions returning Nodes are defined inside class due, the compiler had some problems with finding Node structure outside it

	DataVar* GetContent(Node* RootN)const;

	Node* Insert(DataVar Data, Node* RootN, int(*Comparator)(DataVar a, DataVar b)=NULL)
	{

		if (RootN == NULL)
		{
			Size++;
			return RootN = new BSTTree<DataVar>::Node(Data);
		}


		//If Comparator is not defined, use standard comparsion symbols, compilator will return error if Symbols are not supported by Data variable
		if (!Comparator)
		{

			if (Data > RootN->Data)
			{
				RootN->Right = Insert(Data, RootN->Right);
			}
			else
			{
				RootN->Left = Insert(Data, RootN->Left);
			}
			return RootN;
		}


		//else use comparator, comparator needs to return int: 1 if Data is greater than data in node
        //-1 if data is lower than data in node
        //0 if datas are equal
		else
		{
			//Compatator is int type, so when data is equal, just turn right
			if (Comparator(Data, RootN->Data) == 1 || Comparator(Data, RootN->Data) == 0)
			{
				RootN->Right = Insert(Data, RootN->Right);
			}
			else
			{
				RootN->Left = Insert(Data, RootN->Left);
			}
			return RootN;
		}
	};

	DataVar* VectorToArray(const vector<DataVar>& Data)const 
	{
		DataVar* DataArr = new DataVar[Data.size()];
		int x = 0;
		for (auto itr=Data.begin(), end=Data.end(); itr != end; ++itr)
		{
			DataArr[x] = *itr;
			x++;
		}
		return DataArr;
	};
	

	Node* Find(Node* RootN, DataVar Data, int(*Comparator)(DataVar a, DataVar b) = NULL)
	{
		if (RootN == NULL)
			return NULL;

		//If Comparator is not defined, use standard comparsion symbols, compilator will return error if Symbols are not supported by Data variable
		if (!Comparator)
		{
			if (Data > RootN->Data)
				return Find(RootN->Left, Data);
			else if (Data > RootN->Data)
				return Find(RootN->Right, Data);
			else
				return RootN;
		}

		//else use comparator, comparator needs to return int: 1 if Data is greater than data in node
		//-1 if data is lower than data in node
		//0 if datas are equal
		else
		{ 
			if (Comparator(Data, RootN->Data)==-1)
				return Find(RootN->Left, Data);
			else if (Comparator(Data, RootN->Data)==1)
				return Find(RootN->Right, Data);
			else
				return RootN;
		}

	};

	Node* Remove(DataVar Data, Node* RootN, int(*Comparator)(DataVar a, DataVar b) = NULL) 
	{
		Node* temp;
		if (RootN == NULL)
			return NULL;

		if (!Comparator)
		{
			if (Data < RootN->Data)
				RootN->Left = Remove(Data, RootN->Left);
			else if (Data > RootN->Data)
				RootN->Right = Remove(Data, RootN->Right);
			else if (RootN->Left && RootN->Right)
			{
				temp = Find_Min(RootN->Right);
				RootN->Data = temp->Data;
				RootN->Right = Remove(RootN->Data, RootN->Right);
			}
			else
			{
				temp = RootN;
				if (RootN->Left == NULL)
					RootN = RootN->Right;
				else if (RootN->Right == NULL)
					RootN = RootN->Left;
				delete temp;
			}
		}

		else
		{
			if (Comparator(Data, RootN->Data)==-1)
				RootN->Left = Remove(Data, RootN->Left);
			else if (Comparator(Data, RootN->Data) == 1)
				RootN->Right = Remove(Data, RootN->Right);
			else if (RootN->Left && RootN->Right)
			{
				temp = Find_Min(RootN->Right);
				RootN->Data = temp->Data;
				RootN->Right = Remove(RootN->Data, RootN->Right);
			}
			else
			{
				temp = RootN;
				if (RootN->Left == NULL)
					RootN = RootN->Right;
				else if (RootN->Right == NULL)
					RootN = RootN->Left;
				delete temp;
			}
		}

		Size--;
		return RootN;
	}

	Node* Find_Min(Node* RootN)
	{
		if (RootN == NULL)
			return NULL;
		else if (RootN->Left == NULL)
			return RootN;
		else
			return Find_Min(RootN->Left);
	}

	Node* Erase(Node* RootN)
	{
		if (RootN == NULL)
			return NULL;
		else
		{
			Erase(RootN->Left);
			Erase(RootN->Right);
			delete RootN;
		}
		return NULL;
	}
};


/////////////////////////////
//Templates
////////////////////////////
template<class DataVar> DataVar* BSTTree<DataVar>::GetContent(Node* RootN)const 
{
	static vector<DataVar> Data;
	if(RootN!=NULL)
	{
		GetContent(RootN->Left);
		GetContent(RootN->Right);
		Data.push_back(RootN->Data);
	}
	return VectorToArray(Data);
}
#endif